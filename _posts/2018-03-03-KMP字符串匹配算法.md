---
title: KMP字符串匹配算法
date: 2018-03-03
tags: [算法]
---

# 参考资料

[（原创）详解KMP算法](https://www.cnblogs.com/yjiyjige/p/3263858.html)

[KMP算法最浅显理解——一看就明白](http://blog.csdn.net/starstar1992/article/details/54913261)

# 概述

![](http://p1rbtn7qp.bkt.clouddn.com/18-1-19/39522031.jpg)

当这里匹配失败， 我们不用从上面的第二个开始重新弄

即不用把i=1, j=0重新对照匹配

直接

![](http://p1rbtn7qp.bkt.clouddn.com/18-1-19/38598709.jpg)

因为模式串一开始是A， 而前面匹配过的除了用了的第一个A， 只剩一个A， 所以从这里开始重新来就好了

下面同理

![](http://p1rbtn7qp.bkt.clouddn.com/18-1-19/52335891.jpg)

开头是AB， 而前面匹配过的只有一个AB， 跳到那里重新开始就好了， 不用跳到开头的下一个重新来

![](http://p1rbtn7qp.bkt.clouddn.com/18-1-19/47809447.jpg)

# 最长匹配前后缀

开头是什么， 也就是看匹配过的部分的前缀和后缀相同的最长的情况

abcjkdabc，那么这个数组的最长前缀和最长后缀相同必然是abc 

cbcbc，最长前缀和最长后缀相同是cbc

abcbc，最长前缀和最长后缀相同是不存在的

把这些做成一个叫next[]的数组， 数组长为最长前缀的长度

next[几]就是看前几位的最长前后缀匹配情况

ababaca，长度是7，所以next[0]，next[1]，next[2]，next[3]，next[4]，next[5]，next[6]分别计算的是如下串

a，ab，aba，abab，ababa，ababac，ababaca

他们各自的最长前后缀匹配是“”，“”，“a”，“ab”，“aba”，“”，“a”

所以next数组的值是[-1,-1,0,1,2,-1,0]，这里-1表示不存在，0表示存在长度为1，2表示存在长度为3

# KMP

如果T[i]和P[j]匹配失败

那么把j=next[j]就好了

这就是KMP算法

# 求next数组

next[7]=3表示

当前模式串和主串匹配第7位, 发现不匹配, 主串后移一位, 模式串移到第3位

求next值的几个特例如下

## next[0]

next[0], 也就是模式串第一位就匹配失败该转向哪里

next[0]=-1

![](http://p1rbtn7qp.bkt.clouddn.com/18-1-19/13693409.jpg)

## next[1]

next[1]=0

![](http://p1rbtn7qp.bkt.clouddn.com/18-1-19/19071220.jpg)

## 已知next[j]求next[j+1]

### P[k]=P[j]

这里是求next[j+1]

这里是核心代码, 都是这么求

这里的k是模式串从0开始到j这里的全闭区间的最长匹配前后缀, k就指向前缀的最后一位

![](http://p1rbtn7qp.bkt.clouddn.com/18-1-19/10062390.jpg)

↑现在已知了next[j], 求next[j+1], 求的时候又发现P[k]=P[j]

也就是在D这个位置如果匹配失败, 该转向哪里

很明显要转向第二个A这个位置, 保留前面对应的ABC

也即是next[j+1]=k+1

![](http://p1rbtn7qp.bkt.clouddn.com/18-1-19/18600968.jpg)

### P[k]!=P[j]

这里是改变k, 找最长匹配前后缀

![](http://p1rbtn7qp.bkt.clouddn.com/18-1-19/70040729.jpg)

↑现在已知了next[j], 求next[j+1], 求的时候又发现P[k]!=P[j]

这时候发现最长匹配前后缀为AB(从0开始到j的闭区间哦)(已经不能是ABAB了, 因为最后一位B不匹配了)

此时不是要直接求出next[j+1]

而是修改k值, 使得符合P[k]=P[j], 进入P[k]=P[j]的算法里去求出next[j+1]

这也是合理的, 因为k代表最长匹配前后缀最后一位, 这里发现P[k]!=P[j]后, 最长匹配前后缀的最后一位就已经变了, 不再是k

而应是next[k]

为什么呢, next[k]表示在k位置不匹配时转向哪里

而k以前的是已经和后缀匹配的了

也就是0-k对应了后缀, 只是恰好k这一位没有对应后缀最后一位

仔细看看这个逻辑不就是一个求next么, 所以k(对应求next的j)变成next[k]\(对应j变成next[j]\)

改变了k, 接下来就是把next[j+1]=k+1就好了

### 总结

**kmp就是当ij不匹配时, j=最长匹配前缀的最后一位的后面一位**

next数组的P[k]!=P[j]负责找出最长匹配前缀的最后一位

next数组的P[k]=P[j]负责把找到的最长匹配前缀的最后一位的后一位赋值到next数组

# 代码

## 求next数组

```
//求next数组
public static int[] getNext(String ps) {
    char[] p = ps.toCharArray();
    int[] next = new int[p.length];
    next[0] = -1;
    int j = 0;
    int k = -1;
    while (j < p.length - 1) {
       if (k == -1 || p[j] == p[k]) {
           next[++j] = ++k;
       } else {
           k = next[k];
       }
    }
    return next;
}
```

## KMP算法

```
//KMP算法
public static int KMP(String ts, String ps) {
    char[] t = ts.toCharArray();
    char[] p = ps.toCharArray();
    int i = 0; // 主串的位置
    int j = 0; // 模式串的位置
    int[] next = getNext(ps);
    while (i < t.length && j < p.length) {
       if (j == -1 || t[i] == p[j]) { // 当j为-1时，要移动的是i，当然j也要归0
           i++;
           j++;
       } else {
           // i不需要回溯了
           // i = i - j + 1;
           j = next[j]; // j回到指定位置
       }
    }
    if (j == p.length) {
       return i - j;
    } else {
       return -1;
    }
}
```

# MPI并行化

## 方法一

模式串长m, 则每一个处理器分到的主串后m-1个字符都无法完全校验(倒数第m个可以), 所以可以把后m-1个字符发到下一个处理器, 下一个处理器将它和自己的字符串(也包括自己的后m-1个)合并作为主串来求KMP

也就是将后m-1个字符冗余分布了, 每个后m-1都多了一个副本

## 方法二

后面m-1可以用kmp找出最长匹配前缀串, 将这个串长发给下一个处理器, 下一个处理器接着匹配

因此上一个处理器结束时, 它的j逻辑上会指向下一个处理器的头部, j-1即为自己后m-1的最长前缀(以上前缀指的是相对于后一个处理器的前缀, 因为该处理器的后m-1合并上下一处理器的前m-1才能完整判断)